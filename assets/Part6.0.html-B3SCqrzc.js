import{_ as e,c as d,a as i,o as a}from"./app-DaEuJxNx.js";const l={};function s(n,t){return a(),d("div",null,[...t[0]||(t[0]=[i(`<h1 id="part-6-0-数据包基础" tabindex="-1"><a class="header-anchor" href="#part-6-0-数据包基础"><span>Part 6.0 数据包基础</span></a></h1><p>本章你将学到：</p><ul><li>什么是数据包</li><li>数据包的结构</li></ul><h2 id="同步" tabindex="-1"><a class="header-anchor" href="#同步"><span>同步</span></a></h2><ul><li>同步指客户端、服务器通过数据包来将游戏状态发送给彼此，以达到两端游戏数据相同的过程。<br> 举个例子：假如A玩家在游戏中生成了一个弹幕，那么A玩家就会向服务器发送一个数据包，告诉服务器他在游戏里生成了一个新的弹幕，服务器会将这个弹幕储存起来，然后发送数据包给其他玩家，告知A玩家生成了一个新的弹幕。<br> 这个过程就是同步。</li><li>在上面的例子中，A玩家首先发送数据包和服务器同步，服务器再发送数据包和其他玩家同步，这样以来服务器、所有的客户端的对应的弹幕均相同，保证游戏里每一个玩家都能在相同的位置看见这个弹幕。</li></ul><h2 id="数据包" tabindex="-1"><a class="header-anchor" href="#数据包"><span>数据包</span></a></h2><p>数据包是一种数据结构，就好比服主们喜欢用的JSON数据结构一样。数据包精简，体积小，适合传输；JSON体积更大，但更适合人阅读。 举个例子：<code>TileGetSection(客户端请求获取区块) [8]</code> 这个数据包用JSON表示如下</p><div class="language-json5 line-numbers-mode" data-highlighter="shiki" data-ext="json5" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-json5"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">    &quot;Type&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">8</span><span style="--shiki-light:white;--shiki-dark:#FFFFFF;"> //byte</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">    &quot;TileX&quot;</span><span style="--shiki-light:white;--shiki-dark:#FFFFFF;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 114</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//int</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">    &quot;TileY&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">514</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//int</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>他的数据包形式对应<code>[9,0,8,114,0,0,0,2,2,0,0]</code>(byte[])，这是每个数字对应的含义</p><table><thead><tr><th style="text-align:center;">偏移量(Offset)</th><th style="text-align:center;">大小(Size)</th><th>字段</th><th>值（十进制）</th><th>值（十六进制）</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center;">0</td><td style="text-align:center;">2</td><td>Packet Length</td><td><code>9</code> (<code>[9,0]</code>)</td><td><code>0x0009</code></td><td>数据包总长度 = 9 字节</td></tr><tr><td style="text-align:center;">2</td><td style="text-align:center;">1</td><td>Packet Type</td><td><code>8</code></td><td><code>0x08</code></td><td>数据包类型（8号数据包表示客户端请求获取区块）</td></tr><tr><td style="text-align:center;">3</td><td style="text-align:center;">4</td><td>TileX</td><td><code>114, 0, 0, 0</code></td><td><code>0x72 0x00 0x00 0x00</code></td><td>int32大小为4字节，所以字段有4个</td></tr><tr><td style="text-align:center;">7</td><td style="text-align:center;">4</td><td>TileY</td><td><code>2, 2, 0, 0</code></td><td><code>0x02 0x02 0x00 0x00</code></td><td>同上</td></tr></tbody></table><p>数据包的二进制格式<strong>不像 JSON 那样通过键（如 <code>Type</code>、<code>TileX</code>）标识字段</strong>，而是通过协议约定的<code>字节偏移量(Offset)</code>和<code>字段长度(Size)</code>来定位数据。<br> 例如，要解析 <code>TileX</code>：</p><ol><li>根据协议，<code>TileX</code> 的偏移量是 <code>3</code>（从 0 开始计数）。</li><li>读取接下来的 <code>4</code> 个字节（因为 <code>TileX</code> 是 <code>int32</code>）。</li><li>按约定的字节序<code>Little Endian(小端序)</code>解析为整数值。//你只要知道是<code>Little Endian(小端序)</code>就好了</li></ol><div class="hint-container note"><p class="hint-container-title">注</p><p>在网络传输中，字节存储顺序有<code>Little Endian(小端序)</code>和<code>Big Endian(大端序)</code>之分，泰拉瑞亚的网络协议使用的是<code>Little Endian(小端序)</code> ## 数据包结构</p></div><table><thead><tr><th style="text-align:center;">偏移量 (Offset)</th><th style="text-align:center;">大小 (Size)</th><th>描述 (Description)</th><th>类型 (Type)</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center;">0</td><td style="text-align:center;">2</td><td>PacketLength(数据包长度)（字节）</td><td>ushort</td><td>-</td></tr><tr><td style="text-align:center;">2</td><td style="text-align:center;">1</td><td>PacketType(数据包类型)</td><td>byte</td><td>使用<code>TSAPI.PacketTypes.PacketName</code> 枚举值</td></tr><tr><td style="text-align:center;">3</td><td style="text-align:center;">?</td><td>Data(数据内容)</td><td>?</td><td>具体结构参考后续字段定义</td></tr></tbody></table><ol><li><p><strong>偏移量 (Offset)</strong></p><ul><li>表示字段的<strong>起始位置</strong>（从 0 开始计数，类似数组索引）。</li><li>例如：<code>PacketType</code> 的偏移量是 <code>2</code>，表示从第 3 个字节开始。</li></ul></li><li><p><strong>大小 (Size)</strong></p><ul><li>字段占用的<strong>字节数</strong>。</li><li>例如：<code>PacketLength</code> 占 2 字节，<code>Packet Type</code> 占 1 字节。</li></ul></li><li><p><strong>类型 (Type)</strong></p><ul><li>数据类型，数据类型决定这个字段所占大小，下表是常见类型：</li></ul></li></ol><table><thead><tr><th><strong>类型 (Type)</strong></th><th><strong>大小 (Size)</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>bool</code></td><td>1 字节 (Byte)</td><td>布尔值 (<code>true</code>/<code>false</code>)</td></tr><tr><td><code>byte</code></td><td>1 字节 (Byte)</td><td>无符号 8 位整数 (0 ~ 255)</td></tr><tr><td><code>char</code></td><td>2 字节 (Bytes)</td><td>UTF-16 字符</td></tr><tr><td><code>short</code></td><td>2 字节 (Bytes)</td><td>有符号 16 位整数 (-32,768 ~ 32,767)</td></tr><tr><td><code>ushort</code></td><td>2 字节 (Bytes)</td><td>无符号 16 位整数 (0 ~ 65,535)</td></tr><tr><td><code>int</code></td><td>4 字节 (Bytes)</td><td>有符号 32 位整数 (-2,147,483,648 ~ 2,147,483,647)</td></tr><tr><td><code>float</code></td><td>4 字节 (Bytes)</td><td>32 位单精度浮点数</td></tr><tr><td><code>long</code></td><td>8 字节 (Bytes)</td><td>有符号 64 位整数 (-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807)</td></tr><tr><td><code>double</code></td><td>8 字节 (Bytes)</td><td>64 位双精度浮点数</td></tr><tr><td><code>string</code></td><td>变长 (可变)</td><td>UTF-16 字符串，实际大小取决于字符数量</td></tr></tbody></table><ol start="4"><li><p><strong>数据包长度 (Packet length)</strong></p><ul><li>表示整个数据包的总字节数（包含自身）。</li><li>例如：如果长度字段的值是 <code>[9, 0]</code>（小端序），则总长度 = 9 字节。</li></ul></li><li><p><strong>数据包类型 (Packet Type)</strong></p><ul><li>包号，代表数据包的功能（如 <code>8</code> = 请求区块）。</li><li>建议用<code>TSAPI.PackeTypes.PacketName</code>提高代码可读性。</li></ul></li><li><p><strong>数据内容 (Data)</strong></p><ul><li>实际的有效载荷(Payload)，也就是数据包携带的数据，结构因包类型而异。</li><li>需要查阅具体协议文档或者反编译代码才能解析。</li><li>例如：上面例子中的TileX，TileY</li></ul></li></ol>`,17)])])}const r=e(l,[["render",s]]),c=JSON.parse('{"path":"/zh/plugin-dev/Part6.0.html","title":"Part 6.0 数据包基础","lang":"zh-CN","frontmatter":{"description":"Part 6.0 数据包基础 本章你将学到： 什么是数据包 数据包的结构 同步 同步指客户端、服务器通过数据包来将游戏状态发送给彼此，以达到两端游戏数据相同的过程。 举个例子：假如A玩家在游戏中生成了一个弹幕，那么A玩家就会向服务器发送一个数据包，告诉服务器他在游戏里生成了一个新的弹幕，服务器会将这个弹幕储存起来，然后发送数据包给其他玩家，告知A玩家生...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Part 6.0 数据包基础\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-09-11T05:14:27.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"http://docs.terraria.ink/zh/plugin-dev/Part6.0.html"}],["meta",{"property":"og:site_name","content":"TShock中文插件库"}],["meta",{"property":"og:title","content":"Part 6.0 数据包基础"}],["meta",{"property":"og:description","content":"Part 6.0 数据包基础 本章你将学到： 什么是数据包 数据包的结构 同步 同步指客户端、服务器通过数据包来将游戏状态发送给彼此，以达到两端游戏数据相同的过程。 举个例子：假如A玩家在游戏中生成了一个弹幕，那么A玩家就会向服务器发送一个数据包，告诉服务器他在游戏里生成了一个新的弹幕，服务器会将这个弹幕储存起来，然后发送数据包给其他玩家，告知A玩家生..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-11T05:14:27.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-11T05:14:27.000Z"}]]},"git":{"updatedTime":1757567667000,"contributors":[{"name":"Cai","username":"Cai","email":"13110818005@qq.com","commits":1,"url":"https://github.com/Cai"}],"changelog":[{"hash":"a9215a4f18e1d7379ea613ba1560973941096ec8","time":1757567667000,"email":"13110818005@qq.com","author":"Cai","message":"chore: 将插件教程移动到此仓库，原仓库不再维护"}]},"autoDesc":true,"filePathRelative":"zh/plugin-dev/Part6.0.md"}');export{r as comp,c as data};
