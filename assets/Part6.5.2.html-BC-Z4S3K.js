import{_ as t,c as e,a as s,o as a}from"./app-CVSnDHte.js";const n={};function l(d,i){return a(),e("div",null,[...i[0]||(i[0]=[s(`<h1 id="part-6-5-2-客户端与服务端的连接-不要求学会-仅做参考" tabindex="-1"><a class="header-anchor" href="#part-6-5-2-客户端与服务端的连接-不要求学会-仅做参考"><span>Part 6.5.2 客户端与服务端的连接 (不要求学会，仅做参考)</span></a></h1><p>本章你将学到：</p><ul><li>客户端连接服务端的过程</li><li>对Terraria的数据协议有所了解</li></ul><h2 id="为什么学这个" tabindex="-1"><a class="header-anchor" href="#为什么学这个"><span>为什么学这个？</span></a></h2><p>如果你想写个多世界代理，或者了解多世界代理是如何工作，又或者你想在客户端与服务端连接时做一些额外的事情。<br> 例如: CaiBotPlugin(现在叫Lite了)处理掉玩家发送PlayerInfo(4)来校验白名单, 跨版本插件处理ConnectRequest(1)数据包来实现忽略版本检测</p><h2 id="几个概念" tabindex="-1"><a class="header-anchor" href="#几个概念"><span>几个概念</span></a></h2><h3 id="数据包" tabindex="-1"><a class="header-anchor" href="#数据包"><span>数据包</span></a></h3><ul><li>数据包是服务器和客户端通信的最小单位。其实客户端和服务器通信并不难理解，就像两个人互发短信一样，而服务器和客户端的短信就是数据包</li><li>数据包根据发送方向可分为3种，分别是<code>服务端数据包</code>、<code>客户端数据包</code>、<code>同步数据包</code><table><thead><tr><th style="text-align:center;">类型</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center;">服务端数据包</td><td>服务器 -&gt; 客户端</td><td>只有服务端发送有效，且只有客户端会处理</td></tr><tr><td style="text-align:center;">客户端数据包</td><td>服务器 &lt;- 客户端</td><td>只有客户端发送有效，且只有服务端会处理</td></tr><tr><td style="text-align:center;">同步数据包</td><td>服务器 &lt;-&gt; 客户端</td><td>顾名思义，客户端和服务器用来同步状态的数据包，是双向的，服务器和客户端都会处理</td></tr></tbody></table></li></ul><h3 id="网络模式" tabindex="-1"><a class="header-anchor" href="#网络模式"><span>网络模式</span></a></h3><ul><li>为什么会有<code>网络模式(NetMode)</code>?因为Terraria服务端和客户端都共用一套代码(基本上都一样), 所以在处理数据包时，就要知道本程序是服务器还是客户端，应该执行哪一段逻辑</li><li>网络模式也叫NetMode，对应的字段是<code>Main.netMode</code>，它表示程序在数据传输中的角色，在目前的Terraria有3种网络模式 <table><thead><tr><th style="text-align:center;">ID</th><th>模式</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center;">0</td><td>本地</td><td>单人模式客户端</td></tr><tr><td style="text-align:center;">1</td><td>客户端</td><td>多人模式客户端</td></tr><tr><td style="text-align:center;">2</td><td>服务端</td><td>多人模式服务端</td></tr></tbody></table></li><li>在Terraria中负责解析数据包的<code>MessageBuffer.GetData</code>就有许多代码用来区分客户端、服务器，但是没有本地 😦<div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-csharp"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">case</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//在协议中，Disconnect(2)数据包代表踢出客户端</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">Main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">netMode</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> !=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//若不是客户端模式则退出，说明这个数据包只有客户端才处理，是服务端数据包。</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    break</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">  Netplay</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">Disconnect</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//将客户端状态设为断开连接</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">  Main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">statusText</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> NetworkText</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Deserialize</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">reader</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">).</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ToString</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//显示踢出的理由</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  break</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="连接状态" tabindex="-1"><a class="header-anchor" href="#连接状态"><span>连接状态</span></a></h3><ul><li><p>连接状态表示客户端的连接状态，用来区分不同的连接阶段，在代码中对应的字段为<code>Netplay.Connection(客户端)</code>、<code>Netplay.Clients[Index].State(服务端)</code>、<code>TSPlayer.State(TShock, 与服务端的等价)</code></p></li><li><p>连接状态也分为两种</p><ul><li>服务端的客户端连接状态 <code>Netplay.Clients[Index].State</code> 表示服务器连接的每个客户端的连接状态</li><li>客户端连接状态 <code>Netplay.Connection</code> 表示本地客户端的连接状态</li></ul><table><thead><tr><th style="text-align:center;">ID</th><th>名字</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center;">-1</td><td>AwaitingPassword</td><td>服务器受密码保护，连接处于等待状态，直到客户端发送密码。</td></tr><tr><td style="text-align:center;">0</td><td>AwaitingVersionCheck</td><td>TCP连接已建立，客户端必须验证其版本。</td></tr><tr><td style="text-align:center;">1</td><td>AssigningPlayerSlot</td><td>服务器已接受客户端的连接密码/已验证客户端的版本字符串正确。客户端正在被分配玩家位置。</td></tr><tr><td style="text-align:center;">2</td><td>AwaitingPlayerInfo</td><td>客户端已收到玩家位置，服务器正在等待玩家信息。</td></tr><tr><td style="text-align:center;">3</td><td>RequestingWorldData</td><td>已收到玩家信息，客户端正在请求世界数据。</td></tr><tr><td style="text-align:center;">4</td><td>ReceivingWorldData</td><td>世界数据正在发送给客户端。</td></tr><tr><td style="text-align:center;">5</td><td>FinalizingWorldLoad</td><td>已接收世界数据，客户端正在完成加载。</td></tr><tr><td style="text-align:center;">6</td><td>RequestingTileData</td><td>客户端正在请求图块数据。</td></tr><tr><td style="text-align:center;">10</td><td>Complete</td><td>连接过程完成（玩家已生成），客户端已完全加入游戏。</td></tr></tbody></table></li><li><p>在Terraria中负责解析数据包的<code>MessageBuffer.GetData</code>的前几个数据包就有用来判断玩家连接状态的代码</p><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-csharp"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">case</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">Main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">netMode</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> !=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//属于客户端的逻辑</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    break</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">Netplay</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">Connection</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">State</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//如果客户端连接状态为\`AssigningPlayerSlot(1)\`</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    Netplay</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">Connection</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">State</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//将客户端的连接状态设为\`AwaitingPlayerInfo(2)\`</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h2 id="连接流程-注意-服务器和客户端连接状态是不同的" tabindex="-1"><a class="header-anchor" href="#连接流程-注意-服务器和客户端连接状态是不同的"><span>连接流程 (注意: 服务器和客户端连接状态是不同的!!!)</span></a></h2><ol><li>客户端(0) &lt;-&gt; 服务器: 建立TCP连接 客户端向服务器发起TCP连接，经过三次握手，成功创建TCP连接<br> 客户端: 将连接状态<code>AwaitingVersionCheck(0)</code>设为<code>AssigningPlayerSlot(1)</code><br> 服务器: 将连接状态设为<code>AwaitingVersionCheck(0)</code></li><li>客户端(1) -&gt; 服务器(0): <code>ConnectRequest(1)</code>,<br> 这个数据包包含了客户端的版本信息。 服务器: 若服务器设置了密码，服务器将会将连接状态设为<code>AwaitingPassword(-1)</code>并发送数据包<code>PasswordRequired(37)</code>,若没有密码则直接将连接状态设为<code>AssigningPlayerSlot(1)</code>然后发送数据包<code>ContinueConnecting(3)</code></li><li>服务器(-1) -&gt; 客户端(1): <code>PasswordRequired(37)</code> (没有密码则跳过3,4步骤)<br> 这个数据包不包含数据，只用来表示服务器请求客户端提交密码<br> 客户端: 让用户输入服务器密码，并且发送数据包<code>PasswordSend(38)</code></li><li>客户端(1) -&gt; 服务器(-1): <code>PasswordSend(38)</code><br> 这个数据包传输客户端发送的密码<br> 服务器: 若密码正确则将连接状态设为<code>AssigningPlayerSlot(1)</code>然后发送数据包<code>ContinueConnecting(3)</code>, 若密码不正确则发送数据包<code>Disconnect(2)</code>踢出玩家</li><li>服务器(1) -&gt; 客户端(1): <code>ContinueConnecting(3)</code><br> 这个数据包表示连接继续<br> 客户端: 将连接状态设为<code>AwaitingPlayerInfo(2)</code>, 并且发送数据包<code>PlayerInfo(4)</code>、<code>ClientUUID(68)</code>、<code>PlayerHp(16)</code>、<code>PlayerMana(42)</code>、 <code>PlayerBuff(50)</code>、<code>SyncLoadout(147)</code>、<code>PlayerSlot(5)</code>x背包格数(含装备、储罐等)、<code>ContinueConnecting2(6)</code>，发送完成后将连接状态设置为<code>RequestingWorldData(3)</code></li><li>客户端(3) -&gt; 服务器(1): <code>PlayerInfo(4)</code><br> 这个数据包包含玩家的一些基本信息，比如名字、皮肤等。<br> 服务器: 若玩家名字合规、玩家难度与地图匹配则，服务器向其他客户端(除正在连接的客户端)发送数据包<code>PlayerInfo(4)</code>(同步给其他玩家)</li><li>客户端(3) -&gt; 服务器(1): <code>ClientUUID(68)</code><br> 这个数据包包含玩家的客户端UUID<br> 服务器: 只有TShock服务器才会处理UUID，并且将UUID储存在<code>Netplay.Clients[Index].ClientUUID </code></li><li>客户端(3) -&gt; 服务器(1): <code>ContinueConnecting2(6)</code><br> 这个数据包表面客户端已经将角色信息完全同步给客户端，客户端请求继续连接<br> 服务器: 将连接状态设为<code>AwaitingPlayerInfo(2)</code>, 并且发送数据包<code>WorldInfo(7)</code>，并且向玩家同步入侵信息</li><li>服务器(2) -&gt; 客户端(3): <code>WorldInfo(7)</code><br> 这个数据包包含世界的基本信息, 例如时间、出生点位置等，用来同步世界信息<br> 客户端: 同步世界信息，并将连接状态设置为<code>ReceivingWorldData(4)</code>，然后设置连接状态为<code>FinalizingWorldLoad(5)</code>，接着完成一些初始化世界的操作，然后将连接状态设置为<code>RequestingTileData(6)</code>，最后发送数据包<code>TileGetSection(8)</code></li><li>客户端(6) -&gt; 服务器(2): <code>TileGetSection(8)</code><br> 这个数据包用来请求服务器的区块数据，用来同步地图<br> 服务器: 发送数据包<code>WorldInfo(7)</code>同步世界信息，将连接状态设为<code>RequestingWorldData(3)</code>, 然后发送数据包<code>Status(9)</code>客户端显示正在接受图格信息, 并开始发送区块<code>SendSection</code>（发送多组数据包<code>TileSendSection(10)</code>和<code>NpcUpdate(23)</code>分别同步区块和生物，接着发送数据包<code>ItemDrop(21)</code>和<code>ItemOwner(22)</code>同步掉落物, 然后发送多个数据包<code>NpcKillCount(83)</code>来同步图鉴，然后发送数据包<code>UpdateGoodEvil(57)</code>更新邪恶和神圣，发送数据包<code>MoonLordCountdown(103)</code>同步月总倒计时，发送数据包<code>UpdateShieldStrengths(101)</code>同步四柱进度，发送数据包<code>SyncCavernMonsterType(136)</code>同步这个世界的洞穴怪物类型(蝾螈，卷壳怪，龙虾三选二)，最后发送数据包<code>PlayerSpawnSelf(49)</code>生成玩家</li><li>服务器(3) -&gt; 客户端(6): <code>PlayerSpawnSelf(49)</code><br> 这个数据包用来生成玩家，客户端收到此数据包后玩家会出生在出生点<br> 客户端: 将连接状态设为<code>Complete(10)</code>完成连接, 并且生成玩家，并且发送数据包<code>PlayerSpawn(12)</code>以完成出生</li><li>客户端(10) -&gt; 服务器(3): <code>PlayerSpawn(12)</code><br> 这个数据包用来同步告诉服务器玩家已经出生<br> 服务器: 将连接状态设为<code>Complete(10)</code>完成连接，接着服务器会判断玩家是否为是Host玩家(直接使用多人模式开服), 接着向服务器向其他客户端(除正在连接的客户端)发送数据包<code>PlayerSpawn(12)</code>以同步玩家的出生，接着发送<code>PlaceObject(79)</code>，然后发送<code>FinishedConnectingToServer(129)</code>完成连接, 最后发送欢迎消息</li><li>服务器(10) -&gt; 客户端(10): <code>FinishedConnectingToServer(129)</code><br> 这个数据包标志着连接完成，客户端会进行世界和UI的设置，玩家正式加入游戏。</li></ol>`,14)])])}const h=t(n,[["render",l]]),o=JSON.parse('{"path":"/zh/plugin-dev/Part6.5.2.html","title":"Part 6.5.2 客户端与服务端的连接 (不要求学会，仅做参考)","lang":"zh-CN","frontmatter":{"description":"Part 6.5.2 客户端与服务端的连接 (不要求学会，仅做参考) 本章你将学到： 客户端连接服务端的过程 对Terraria的数据协议有所了解 为什么学这个？ 如果你想写个多世界代理，或者了解多世界代理是如何工作，又或者你想在客户端与服务端连接时做一些额外的事情。 例如: CaiBotPlugin(现在叫Lite了)处理掉玩家发送PlayerInf...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Part 6.5.2 客户端与服务端的连接 (不要求学会，仅做参考)\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-09-11T05:14:27.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"http://docs.terraria.ink/zh/plugin-dev/Part6.5.2.html"}],["meta",{"property":"og:site_name","content":"TShock中文插件库"}],["meta",{"property":"og:title","content":"Part 6.5.2 客户端与服务端的连接 (不要求学会，仅做参考)"}],["meta",{"property":"og:description","content":"Part 6.5.2 客户端与服务端的连接 (不要求学会，仅做参考) 本章你将学到： 客户端连接服务端的过程 对Terraria的数据协议有所了解 为什么学这个？ 如果你想写个多世界代理，或者了解多世界代理是如何工作，又或者你想在客户端与服务端连接时做一些额外的事情。 例如: CaiBotPlugin(现在叫Lite了)处理掉玩家发送PlayerInf..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-11T05:14:27.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-11T05:14:27.000Z"}]]},"git":{"updatedTime":1757567667000,"contributors":[{"name":"Cai","username":"Cai","email":"13110818005@qq.com","commits":1,"url":"https://github.com/Cai"}],"changelog":[{"hash":"a9215a4f18e1d7379ea613ba1560973941096ec8","time":1757567667000,"email":"13110818005@qq.com","author":"Cai","message":"chore: 将插件教程移动到此仓库，原仓库不再维护"}]},"autoDesc":true,"filePathRelative":"zh/plugin-dev/Part6.5.2.md"}');export{h as comp,o as data};
